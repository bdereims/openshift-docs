// Module included in the following assemblies:
//
// * operators/osdk-getting-started.adoc

<<<<<<< HEAD
[id='building-memcached-operator-using-osdk_{context}']
=======
[id='building-memcached-oeprator-using-osdk_{context}']
>>>>>>> 6bcfc60496ce2d67bb2988b30404317813a382f5
= Building a Memcached Operator using the Operator SDK

The Operator SDK makes it easier to build Kubernetes native applications, a
process that can require deep, application-specific operational knowledge. The
SDK not only lowers that barrier, but it also helps reduce the amount of
boilerplate code needed for many common management capabilities, such as
metering or monitoring.

This procedure walks through an example of building a simple Memcached Operator
using tools and libraries provided by the SDK.

.Prerequisites

- Operator SDK CLI installed on the development workstation
- Operator Lifecycle Manager (OLM) installed on a Kubernetes-based cluster (v1.8
<<<<<<< HEAD
or above to support the `apps/v1beta2` API group), for example {product-title} 4.0
- Access to the cluster using an account with `cluster-admin` permissions
- link:https://kubernetes.io/docs/tasks/tools/install-kubectl/[`kubectl`] v1.11.3+
(can alternatively use `oc`)

.Procedure

. *Create a new project.*
=======
or above to support the `apps/v1beta2` API group), for example {product-title}
3.11 with Technology Preview OLM enabled
- Access to the cluster using an account with cluster-admin permissions
- link:https://kubernetes.io/docs/tasks/tools/install-kubectl/[`kubectl`] v1.9.0+
(can alternatively use `oc`)


.Procedure

. Create a new project.
>>>>>>> 6bcfc60496ce2d67bb2988b30404317813a382f5
+
Use the CLI to create a new `memcached-operator` project:
+
----
$ cd $GOPATH/src/github.com/example-inc/
<<<<<<< HEAD
$ operator-sdk new memcached-operator
$ cd memcached-operator
----
+
[TIP]
====
See xref:operators-appendices.adoc#operator-project-scaffolding-layout_operator-appendices[Appendices] to
learn about the project directory structure created by the previous commands.
====

. *Add a new Custom Resource Definition (CRD).*

.. Use the CLI to add a new CRD API called `Memcached`, with `APIVersion` set to
`cache.example.com/v1apha1` and `Kind` set to `Memcached`:
+
----
$ operator-sdk add api \
    --api-version=cache.example.com/v1alpha1 \
		--kind=Memcached
----
+
This scaffolds the Memcached resource API under `pkg/apis/cache/v1alpha1/`.

.. Modify the spec and status of the `Memcached` Custom Resource (CR) at the
`pkg/apis/cache/v1alpha1/memcached_types.go` file:
=======
$ operator-sdk new memcached-operator --api-version=cache.example.com/v1alpha1 --kind=Memcached
$ cd memcached-operator
----
+
This creates the `memcached-operator` project specifically for watching the
`Memcached` resource with APIVersion `cache.example.com/v1apha1` and Kind
`Memcached`.
+
See xref:operator-project-scaffolding-layout_osdk-getting-started[Appendices]
for more about the project directory structure.

. Customize the Operator logic.
+
For this example, the Memcached Operator executes the following reconciliation
logic for each `Memcached` custom resource:
+
--
* Create a `Memcached` deployment if it does not exist.
* Ensure that the deployment size is the same as specified by the `Memcached`
link:https://kubernetes.io/docs/concepts/api-extension/custom-resources/[`CustomResource`]
(CR) spec.
* Update the `Memcached` CR status with the names of the `memcached` pods.
--
+
Customize the logic using the following steps:

.. Watch for the Memcached custom resource definition (CRD). By default, the `memcached-operator` watches `Memcached` resource events as shown in `cmd/memcached-operator/main.go`:
+
----
func main() {
	printVersion()

	sdk.ExposeMetricsPort()

	resource := "cache.example.com/v1alpha1"
	kind := "Memcached"
	namespace, err := k8sutil.GetWatchNamespace()
	if err != nil {
		logrus.Fatalf("Failed to get watch namespace: %v", err)
	}
	resyncPeriod := 5
	logrus.Infof("Watching %s, %s, %s, %d", resource, kind, namespace, resyncPeriod)
	sdk.Watch(resource, kind, namespace, resyncPeriod)
	sdk.Handle(stub.NewHandler())
	sdk.Run(context.TODO())
}
----

.. Define the Memcached spec and status.

... Modify the spec and status of the `Memcached` CRD at
`pkg/apis/cache/v1alpha1/types.go`:
>>>>>>> 6bcfc60496ce2d67bb2988b30404317813a382f5
+
----
type MemcachedSpec struct {
	// Size is the size of the memcached deployment
	Size int32 `json:"size"`
}
type MemcachedStatus struct {
	// Nodes are the names of the memcached pods
	Nodes []string `json:"nodes"`
}
----

<<<<<<< HEAD
.. After modifying the `*_types.go` file, always run the following command to
update the generated code for that resource type:
+
----
$ operator-sdk generate k8s
----

. *Add a new Controller.*

.. Add a new Controller to the project to watch and reconcile the Memcached
resource:
+
----
$ operator-sdk add controller \
    --api-version=cache.example.com/v1alpha1 \
		--kind=Memcached
----
+
This scaffolds a new Controller implementation under
`pkg/controller/memcached/`.

.. For this example, replace the generated controller file
`pkg/controller/memcached/memcached_controller.go` with the
link:https://github.com/operator-framework/operator-sdk/blob/master/example/memcached-operator/memcached_controller.go.tmpl[example implementation].
+
The example controller executes the following reconciliation logic for each
`Memcached` CR:
+
--
* Create a Memcached Deployment if it does not exist.
* Ensure that the Deployment size is the same as specified by the `Memcached` CR spec.
* Update the `Memcached` CR status with the names of the Memcached Pods.
--
+
The next two sub-steps inspect how the Controller watches resources and how the
reconcile loop is triggered. You can skip
xref:building-memcached-operator-using-osdk-build-and-run_{context}[skip these steps]
step to go directly to building and running the Operator.

.. Inspect the Controller implementation at the
`pkg/controller/memcached/memcached_controller.go` file to see how the
Controller watches resources.
+
The first watch is for the Memcached type as the primary resource. For each Add,
Update, or Delete event, the reconcile loop is sent a reconcile `Request` (a
`<namespace>:<name>` key) for that Memcached object:
+
----
err := c.Watch(
  &source.Kind{Type: &cachev1alpha1.Memcached{}}, &handler.EnqueueRequestForObject{})
----
+
The next watch is for Deployments, but the event handler maps each event to a
reconcile `Request` for the owner of the Deployment. In this case, this is the
Memcached object for which the Deployment was created. This allows the
controller to watch Deployments as a secondary resource:
+
----
err := c.Watch(&source.Kind{Type: &appsv1.Deployment{}}, &handler.EnqueueRequestForOwner{
		IsController: true,
		OwnerType:    &cachev1alpha1.Memcached{},
	})
----

.. Every Controller has a Reconciler object with a `Reconcile()` method that
implements the reconcile loop. The reconcile loop is passed the `Request`
argument which is a `<namespace>:<name>` key used to lookup the primary resource
object, Memcached, from the cache:
+
----
func (r *ReconcileMemcached) Reconcile(request reconcile.Request) (reconcile.Result, error) {
  // Lookup the Memcached instance for this reconcile request
  memcached := &cachev1alpha1.Memcached{}
  err := r.client.Get(context.TODO(), request.NamespacedName, memcached)
  ...
}
----
+
Based on the return value of `Reconcile()` the reconcile `Request` may be
requeued and the loop may be triggered again:
+
----
// Reconcile successful - don't requeue
return reconcile.Result{}, nil
// Reconcile failed due to error - requeue
return reconcile.Result{}, err
// Requeue for any reason other than error
return reconcile.Result{Requeue: true}, nil
----
[[building-memcached-operator-using-osdk-build-and-run_{context}]]

. *Build and run the Operator.*

.. Before running the Operator, the CRD must be registered with the Kubernetes API
server:
+
----
$ kubectl create \
    -f deploy/crds/cache_v1alpha1_memcached_crd.yaml
----

.. After registering the CRD, there are two options for running the Operator:
+
--
* As a Deployment inside a Kubernetes cluster
* As Go program outside a cluster
--
+
Choose one of the following methods.

... _Option A:_ Running as a Deployment inside the cluster.

.... Build the `memcached-operator` image and push it to a registry:
+
----
$ operator-sdk build quay.io/example/memcached-operator:v0.0.1
----

.... The Deployment manifest is generated at `deploy/operator.yaml`. Update the
Deployment image as follows since the default is just a placeholder:
+
----
$ sed -i 's|REPLACE_IMAGE|quay.io/example/memcached-operator:v0.0.1|g' deploy/operator.yaml
----

.... Ensure you have an account on link:https://quay.io[quay.io] for the next step,
or substitute your preferred container registry. On the registry,
link:https://quay.io/new/[create a new public image] repository named
`memcached-operator`.

.... Push the image to the registry:
+
----
$ docker push quay.io/example/memcached-operator:v0.0.1
----

.... Setup RBAC and deploy `memcached-operator`:
+
----
$ kubectl create -f deploy/role.yaml
$ kubectl create -f deploy/role_binding.yaml
# TODO: $ kubectl create -f deploy/service_account.yaml
$ kubectl create -f deploy/operator.yaml
----

.... Verify that `memcached-operator` is up and running:
+
----
$ kubectl get deployment
NAME                     DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
memcached-operator       1         1         1            1           1m
----

... _Option B:_ Running locally outside the cluster.
+
This method is preferred during development cycle to deploy and test faster.
+
Run the Operator locally with the default Kubernetes configuration file present
at `$HOME/.kube/config`:
+
----
$ operator-sdk up local --namespace=default
2018/09/30 23:10:11 Go Version: go1.10.2
2018/09/30 23:10:11 Go OS/Arch: darwin/amd64
2018/09/30 23:10:11 operator-sdk Version: 0.0.6+git
2018/09/30 23:10:12 Registering Components.
2018/09/30 23:10:12 Starting the Cmd.
----
+
You can use a specific `kubeconfig` using the flag
`--kubeconfig=<path/to/kubeconfig>`.

. *Verify that the Operator can deploy a Memcached application* by creating a
Memcached CR.

.. Create the example `Memcached` CR that was generated at
`deploy/crds/cache_v1alpha1_memcached_cr.yaml`:
+
----
$ cat deploy/crds/cache_v1alpha1_memcached_cr.yaml
=======
... Update the generated code for the CR:
+
----
$ cd $GOPATH/src/github.com/example-inc/
$ cd memcached-operator
$ operator-sdk generate k8s
----

.. Define the Handler. The reconciliation loop for an event is defined in the `Handle()` function at `pkg/stub/handler.go`.
+
Replace this file with the reference implementation found at
link:https://github.com/operator-framework/getting-started/blob/master/handler.go.tmpl#L7[handler_go].
You must update the highlighted line if you have changed the import path of this
project to something other than `example-inc`.
+
[NOTE]
====
The provided handler implementation is only meant to demonstrate the use of the
SDK APIs and is not representative of the best practices of a reconciliation
loop.
====

. Build and run the Operator.

.. Build the `memcached-operator` image and push it to a registry. Ensure you have
an account on link:https://quay.io[quay.io] for the next step, or substitute
your preferred container image registry. On the registry,
link:https://quay.io/new/[create a new public image] repository named
`memcached-operator`.
+
----
$ cd $GOPATH/src/github.com/example-inc/
$ cd memcached-operator
$ operator-sdk build quay.io/example/memcached-operator:v0.0.1
$ docker push quay.io/example/memcached-operator:v0.0.1
----
+
Kubernetes deployment manifests are generated in the *_deploy/operator.yaml_*
file. The deployment image is set to the container image specified above.

.. Log in to your cluster as a user with `cluster-admin` permissions and deploy the
Memcached Operator:
+
----
$ kubectl create -f deploy/rbac.yaml
$ kubectl create -f deploy/crd.yaml
$ kubectl create -f deploy/operator.yaml
----

.. Verify that the `memcached-operator` pod is up and running:
+
----
$ kubectl get pods
NAME                                  READY     STATUS    RESTARTS   AGE
memcached-operator-75c4b4c665-8jnj5   1/1       Running   0          20s
----

. To verify that the Operator can deploy a Memcached application,
create a `Memcached` custom resource (CR).

.. Modify the *_deploy/cr.yaml_* file as shown:
+
----
$ cat deploy/cr.yaml
>>>>>>> 6bcfc60496ce2d67bb2988b30404317813a382f5
apiVersion: "cache.example.com/v1alpha1"
kind: "Memcached"
metadata:
  name: "example-memcached"
spec:
  size: 3
<<<<<<< HEAD

$ kubectl apply -f deploy/crds/cache_v1alpha1_memcached_cr.yaml
----

.. Ensure that `memcached-operator` creates the Deployment for the CR:
+
----
$ kubectl get deployment
=======
----

.. Create the `Memcached` CR:
+
----
$ kubectl apply -f deploy/cr.yaml
----

.. Verify that the Memcached Operator creates the deployment for the CR:
+
----
$ kubectl get deployment

>>>>>>> 6bcfc60496ce2d67bb2988b30404317813a382f5
NAME                     DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
memcached-operator       1         1         1            1           2m
example-memcached        3         3         3            3           1m
----

<<<<<<< HEAD
.. Check the Pods and CR status to confirm the status is updated with the
`memcached` Pod names:
+
----
$ kubectl get pods
=======
.. Check the pods and CR status to confirm the status is updated with the
`memcached` pod names:
+
----
$ kubectl get pods

>>>>>>> 6bcfc60496ce2d67bb2988b30404317813a382f5
NAME                                  READY     STATUS    RESTARTS   AGE
example-memcached-6fd7c98d8-7dqdr     1/1       Running   0          1m
example-memcached-6fd7c98d8-g5k7v     1/1       Running   0          1m
example-memcached-6fd7c98d8-m7vn7     1/1       Running   0          1m
memcached-operator-7cc7cfdf86-vvjqk   1/1       Running   0          2m
<<<<<<< HEAD

$ kubectl get memcached/example-memcached -o yaml
=======
----
+
----
$ kubectl get memcached/example-memcached -o yaml

>>>>>>> 6bcfc60496ce2d67bb2988b30404317813a382f5
apiVersion: cache.example.com/v1alpha1
kind: Memcached
metadata:
  clusterName: ""
  creationTimestamp: 2018-03-31T22:51:08Z
  generation: 0
  name: example-memcached
  namespace: default
  resourceVersion: "245453"
  selfLink: /apis/cache.example.com/v1alpha1/namespaces/default/memcacheds/example-memcached
  uid: 0026cc97-3536-11e8-bd83-0800274106a1
spec:
  size: 3
status:
  nodes:
  - example-memcached-6fd7c98d8-7dqdr
  - example-memcached-6fd7c98d8-g5k7v
  - example-memcached-6fd7c98d8-m7vn7
----

<<<<<<< HEAD
. *Verify that the Operator can manage a deployed Memcached application* by
updating the size of the deployment.

.. Change the `spec.size` field in the `memcached` CR from `3` to `4`:
+
----
$ cat deploy/crds/cache_v1alpha1_memcached_cr.yaml
=======
. To verify that the Operator can manage a deployed Memcached application, update
the size of the deployment.

.. Change the `spec.size` field in the `memcached` CR from 3 to 4:
+
----
$ cat deploy/cr.yaml
>>>>>>> 6bcfc60496ce2d67bb2988b30404317813a382f5
apiVersion: "cache.example.com/v1alpha1"
kind: "Memcached"
metadata:
  name: "example-memcached"
spec:
  size: 4
----

.. Apply the change:
+
----
<<<<<<< HEAD
$ kubectl apply -f deploy/crds/cache_v1alpha1_memcached_cr.yaml
----

.. Confirm that the Operator changes the Deployment size:
+
----
$ kubectl get deployment
=======
$ kubectl apply -f deploy/cr.yaml
----

.. Confirm that the Memcache Operator changes the deployment size:
+
----
$ kubectl get deployment

>>>>>>> 6bcfc60496ce2d67bb2988b30404317813a382f5
NAME                 DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
example-memcached    4         4         4            4           5m
----

<<<<<<< HEAD
. *Clean up the resources:*
+
----
$ kubectl delete -f deploy/crds/cache_v1alpha1_memcached_cr.yaml
$ kubectl delete -f deploy/operator.yaml
=======
. Finally, clean everything up:
+
----
$ kubectl delete -f deploy/operator.yaml
$ kubectl delete -f deploy/rbac.yaml
$ kubectl delete -f deploy/cr.yaml
$ kubectl delete -f deploy/crd.yaml
>>>>>>> 6bcfc60496ce2d67bb2988b30404317813a382f5
----
